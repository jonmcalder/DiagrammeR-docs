[
["index.html", "The DiagrammeR Package This book is not yet finished", " The DiagrammeR Package Richard Iannone 2017-03-21 This book is not yet finished In the book now (in somewhat acceptable form): Basic graph creation. Introduction to graph attributes. Graph selections (nodes and edges). What is coming: An introduction. Traversals. Graph generators. Graph metrics and properties. Graph transformations. Import/Export of graphs. A series of graphs. Node positioning. Whole-graph algorithms. centrality measures. community detection. Use cases. Using the package to mine tweets and model as a graph. Taking several data tables and merging into a complex, multi-domain graph. The repository for this book is: https://github.com/rich-iannone/DiagrammeR-docs The DiagrammeR Package by Richard Iannone is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License. "],
["intro.html", "Chapter 1 Introduction 1.1 Why Model Data as a Graph? 1.2 The DiagrammeR Graph Object", " Chapter 1 Introduction 1.1 Why Model Data as a Graph? Network graphs allow for relationship-based data models. Positioning the relationships between entities as first class lets us more easily model complex, real-world information. A distinguishing feature of network graph models is that the relationships are treated with as much value as the node entity data records themselves. The connections within data are often not considered but we really need to work closely with relationship data to extract valuable insights. Using a network graph usually means you have fast navigation (i.e., traversals) between nodes (performed in constant time). Modeling data with a relational, tabular approach will require working with data as a set of tables and columns, and this necessitates carrying out complex joins and self-joins when the dataset becomes more interrelated. Such queries are technically complicated to construct and can be expensive to run. Furthermore, making them work synchronously is not easy, with performance dropping precipitously as the total dataset size increases. The tabular data model is also typically hard to reason about since it doesn’t readily correspond to mental models for a given application. DiagrammeR provides a framework and collection of functions to model network graphs as property graphs. A property graph is one that has labeled nodes (for informational entities) that are connected via directed, typed relationships. Both nodes and relationships hold arbitrary properties (attributes, as key-value pairs). There is no rigid schema, but with node and edge labeling we can have as much metadata as we’d like. Taking the example of a typical software repository with multiple users, entities can be users, comments, issues, repositories, organizations, etc., and they are related to each other in specific ways. A user can create or delete a repository, and, the same user could also push a commit (a separate entity, having its own metadata) to a repository. The following schematic provides a simplified graph model of how entities can be related to each other in the context of an multiuser software repository. 1.2 The DiagrammeR Graph Object A graph object in DiagrammeR maintains a series of interrelated elements. Most importantly, the set of nodes (vertices) and edges (links) resides here, along with elements for graph metadata such as styling attributes, active node/edge selections, data frames linked to nodes or edges, and other user-defined caches of graph features. The user does not directly modify the contents of the graph object. Rather, the package provides access to a wide range of graph functions for modifying the internal components of the graph object. This both provides ease-of-use and assurances that all graph elements are synchronized, avoiding unintentional corruption of the graph. Nodes and edges contain properties (called attributes throughout) as key-value pairs. Formally, the graph object contains an R data frame for all graph nodes and their attributes (nodes_df) and an analogous data frame for edges and their attributes (edges_df). In the context of DiagrammeR these are typically called the node data frame (ndf) and the edge data frame (edf). There are several additional data frames used to support the modification and display of graphs. The Global Graph Attributes (global_attrs) data frame stores data for the default appearance of a graph when displayed. One entry may include using a fontsize of 10 for each node. Another may affect the whole graph, where the layout is the circo type. These defaults, set for nodes and edges, can be subject to overrides on a per-node or per-edge basis by including values for the same attributes in the node or edge data frames. Two data frames are reserved for node and edge selection values (node_selection and edge_selection). If there is no active selection, then these data frames are empty (i.e., have 0 rows). If there is a selection (and there can only be one type of selection at any given time), then rows containing node IDs or edge IDs will be populated. This will generally persist (even as other graph functions are used) until the selection is formally cleared. These types of selections are useful because we can target specific parts of the graph and apply specific functions that recognize selections to do useful graph work. The graph stores useful metadata about itself such as identifiers and control options (in graph_info) and a log of which graph modification functions were used (in graph_log). This is valuable for the system to understand the graph history and state and this allows for some graph functions to work with less user-provided information. Finally, we have the option to store some other R objects in the graph. One is a cache space for R vectors. This cached vector could consist of a series of labels extracted from one part of the graph that may be useful in a function that does something to another part of the graph. The other reserved space for data is for entire data frames that could belong to any node or edge in the graph. This is great if you have extended metadata that doesn’t easily correspond to a key-value attribute pair. "],
["creation.html", "Chapter 2 Graph Creation 2.1 Getting Started 2.2 Visualizing a Simple Graph 2.3 Using Data Frames 2.4 Adding Basic Attributes 2.5 The Internal NDF/EDF", " Chapter 2 Graph Creation Creating a graph object is undoubtedly important. I dare say it is one of the fundamental aspects of the DiagrammeR world. With the graph object produced, so many other things are possible. For instance, you can inspect certain aspects of the graph, modify the graph in many ways that suit your workflow, view the graph (or part of the graph!) in the RStudio Viewer, or perform graph traversals and thus create complex graph queries using magrittr (%&gt;%) or pipeR (%&gt;&gt;%) pipelines. The possibilities are really very exciting and it all begins with creating those graph objects. 2.1 Getting Started Before we dive into making a graph with DiagrammeR we’d want to be sure some things are in order. First, we need to make sure we have the package installed in R. While the package is available on CRAN, it’s recommended that the development version of DiagrammeR is used. It’s available on GitHub and to install packages from there, we need to use the devtools package. (If not installed use install.packages(&quot;devtools&quot;).) After that, get the development build of DiagrammeR using devtools::install_github(&quot;rich-iannone/DiagrammeR&quot;). Finally, load the package with: library(DiagrammeR) A few notes are useful here, the package automatically enables the magrittr pipe operator (%&gt;%) which allows for chaining between statements in a left-to-right, easy-to-read manner. The pipeR package’s %&gt;&gt;% (which works very similarly) is not loaded by DiagrammeR but it can be used. In the examples throughout, we’ll stick with magrittr’s pipe. 2.2 Visualizing a Simple Graph When considering the visualization of a graph we often have to consider the eventual size of the graph. Size matters both to the computation time of the visualization and also to the effectiveness of the visualization itself. Very large graphs (i.e., millions of nodes) would be difficult to visualize without some care taken to ensure that not all the nodes are actually drawn; otherwise, the visualization may not even be created without out-of-memory errors (or, and I’m not sure this is much better, giant vector graphics files). Furthermore, displaying huge volumes of nodes and edges does not always offer great insight unless great care has been taken toward using visual aesthetics. This tension between visualizing a graph or simply using the graph data to perform queries is often present. However, for now, let’s cast such considerations aside and learn how to create and visualize very simple graphs. We’ll use of few of DiagrammeR’s functions to build up graphs and also to modify the graph. While some of these functions may not be as useful for building graphs with real-world data (where, instead, one might opt for bulk imports of tabular data), it’ll provide some basis for the more advanced functionality we’ll explore later on. 2.2.1 Creating Nodes Let’s get to making a graph. The create_graph() function creates a graph object and, optionally, allows for intialization of nodes, edges, and a few global attributes for the graph. We can create an empty graph by simply using create_graph() as is. graph_e &lt;- create_graph() This really is an empty graph (no nodes) and we can quickly verify this by using the node_count() function. node_count(graph_e) ## [1] 0 You can add individual nodes to a graph by using the add_node() function. Let’s add two nodes in the most minimal fashion: graph_1n &lt;- add_node(graph = graph_e) graph_2n &lt;- add_node(graph = graph_1n) This creates 2 nodes with ID values 1 and 2 (ID values are set for you as auto-incrementing integers). There are a few functions that can be used to check that these additions did occur. We can get a count of nodes as before with the node_count() function: # Count the number of nodes in each graph produced c(node_count(graph = graph_e), node_count(graph = graph_1n), node_count(graph = graph_2n)) ## [1] 0 1 2 Alternatively, we can use the get_node_ids() function to return a vector of node ID values: # Get the node ID values for `graph_2n`; note that # the data argument is `x` and not `graph` get_node_ids(x = graph_2n) ## [1] 1 2 2.2.2 Viewing the Graph Finally, we can visualize the graph by using the render_graph() function. The nodes typically appear very large when there are few of them but scale down in size if there are many. The values shown inside the nodes are the automatically-assigned node ID values. If we were to assign label values to each of the nodes - which could be done when using add_node(label = &quot;label_name&quot;), for example - those values would be shown instead. render_graph(graph = graph_2n) Adding nodes does not automatically add edges. We can check that there are no edges in the graph by using the edge_count() function. A graph with no edges will return 0. edge_count(graph = graph_2n) ## [1] 0 2.2.3 Piping Has Its Advantages The vast majority of the functions in DiagrammeR have the graph argument (or x as we’ve also seen) as their first argument. This is useful in the context of using the magrittr pipe operator, %&gt;% as we can start with a graph object, perform a transformation on that graph, expect a modified graph, and use that as input for the next transformation function, all while joining such operations with the pipe. With this piping approach, we can create the same graph as before (2 nodes, no edges) by chaining with %&gt;%: # Create the equivalent `graph_2n` object # but use `%&gt;%` to avoid intermediate objects graph_2n_piped &lt;- create_graph() %&gt;% add_node() %&gt;% add_node() # Verify that the graph contains 2 nodes node_count(graph_2n_piped) ## [1] 2 The benefits are pretty obvious over the nested approach that avoids creating intermediate graph objects. # Create the equivalent `graph_2n` object # using nested function calls graph_2n_nested_fcns &lt;- add_node( add_node( create_graph())) # Verify that the graph contains 2 nodes node_count(graph_2n_nested_fcns) ## [1] 2 With the %&gt;%, the sequence of operations is more easily readable (left to right), plus, only one name to create! The less names the better. Moreover, and not shown above, the situtation for the nested approach gets more confusing as we add arguments and their values (of which, there can be many). 2.2.4 Adding Edges So, we have made a graph with 2 nodes. The next reasonable thing to do would be adding an edge between the nodes. By default, new graphs produced with create_graph() are directed graphs. To review, a directed graph is one where any edge between a pair of nodes has a defined direction (e.g., by the definition 1-&gt;2, we mean to say that edge is directed from node 1 to node 2). This book mainly deals with directed graphs but we may occasionally delve into undirected graphs (where edges have no specified direction between nodes). At any rate, using create_graph(directed = FALSE) will create an empty graph designated as undirected (i.e., any edges added will be undirected). Let’s use a pipeline with %&gt;% to create a graph with 2 nodes and the edge with definition 1-&gt;2. This requires three different functions (create_graph(), add_node(), and add_edge()): # Create a graph with 2 nodes and 1 edge graph_2n_1e &lt;- create_graph() %&gt;% add_node() %&gt;% add_node() %&gt;% add_edge(from = 1, to = 2) # Describe the graph paste(&quot;This graph has:&quot;, node_count(graph_2n_1e), &quot;nodes,&quot;, edge_count(graph_2n_1e), &quot;edges&quot;) ## [1] &quot;This graph has: 2 nodes, 1 edges&quot; We can be sure we created the correct edge definition (1-&gt;2) by using the get_edges() function: # The graph has 1 edge, what is its # edge definition? get_edges(graph_2n_1e) ## [1] &quot;1-&gt;2&quot; We now have this simple and small graph. We can view it again by calling the render_graph() function. You probably do not want to assign the graph to an object when calling render_graph() (as you would likely mistakenly overwrite a graph you’ve previously made). We are purely using this function for its side effect, which is viewing. We can view the graph using the Graphviz renderer: # Show the graph using the Graphviz engine render_graph(graph = graph_2n_1e) And also, if you like interactivity and fluid physical motions, try using the visNetwork renderer. # Show the graph using the visNetwork engine render_graph(graph = graph_2n_1e, output = &quot;visNetwork&quot;) 2.2.5 Deleting Graph Elements Just as we’ve built up a graph, we can do the opposite and remove edges and nodes. The key functions here are delete_edge() and delete_node(). Let’s remove the edge we just recently added and then remove each of the nodes, leaving us again with an empty graph. Note again that we don’t need to repeat the graph’s object name throughout this pipeline (which is nice, saves typing). Second useful note: typing delete_edge( and then hitting the tab in RStudio brings up useful information on the function’s argument names along with useful descriptions. I find this very helpful and use this feature quite often. # Remove the edge from the graph, then, # remove each of the 2 nodes graph_2n_1e_empty &lt;- graph_2n_1e %&gt;% delete_edge(from = 1, to = 2) %&gt;% delete_node(node = 2) %&gt;% delete_node(node = 1) # Verify that there are no nodes left # in this graph object node_count(graph_2n_1e_empty) ## [1] 0 There are some shortcuts/variations for doing the same thing (there are often numerous ways to transform graphs). You could simply call delete_node() twice, for instance, to get an empty graph. This is because removing a node with edges attached will automatically remove those edges. If we were now to display the graph with render_graph() you would get a field of nothingness. Since that’s not very interesting, I’m not going to show it here. 2.3 Using Data Frames For certain graph diagrams there will be many nodes and edges, and, it may not be practical to add nodes/edges a few at a time. Let’s take advantage of R and its data frames! We can construct a specialized data frame for nodes (a node data frame, or ndf) and include the basic node information (ID values, a type, and a text-based label), and, also include extra columns that could be used for node aesthetics when displayed or even just metadata. To start simply, let’s use the create_node_df() function to specify a minimal collection of nodes in an ndf. create_node_df( n = 3, label = TRUE) id type label 1 NA 1 2 NA 2 3 NA 3 The n argument is required here and it must indicate the number of nodes you intend this object to contain. The use of label = TRUE allows for copying of the node IDs as the node label (which is a node attribute). This is not always desirable, however. A better option is to specify a vector of label values (you can use all manner of characters, it will be coerced to a character vector). Make certain that this vector is the same length as specified by n. Also, if we ensure that the label node attribute always contains unique values, we can later select individual nodes by their label values and perform actions on these selections. You may have noticed the node attribute type in the output (alas, all NAs). Values may optionally be provided for this attribute and, again, having this extra metadata is recommended as it is helpful for categorizing nodes. Let’s display a different ndf object that includes two different type values (A and B) and unique label values that are not strict copies of the node id. ndf &lt;- create_node_df( n = 3, type = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;), label = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) id type label 1 A one 2 A two 3 B three Now onto the edges, those connections between the nodes. The edges are also collected in a data frame (this time, as an edge data frame or edf). The create_edge_df() function is used to generate this type of object. create_edge_df( from = c(1, 1), to = c(2, 3)) id from to rel 1 1 2 NA 2 1 3 NA The from and to arguments specify which nodes for the edge are outgoing and incoming, respectively. Here, the edges are: 1-&gt;2 and 1-&gt;3. As stated before, for directed graphs, the order is essential. The rel argument allows for the inclusion of text labels in the same manner as the node type. This is useful for targeting specific groups of edges during a selection or traversal. Let’s refine the edf object and include two different rel values (X and Y). edf &lt;- create_edge_df( from = c(1, 1), to = c(2, 3), rel = c(&quot;X&quot;, &quot;Y&quot;)) id from to rel 1 1 2 X 2 1 3 Y Now that we have an ndf and an edf, we can combine those into a new graph object by using these specialized data frames within the create_graph() function call. # Create a graph object using node and # edge data frames graph_ndf_edf &lt;- create_graph( nodes_df = ndf, edges_df = edf) What exactly happened? These data frames (ndf and edf) were placed within the graph object when it was created. They essentially became internal ndf and edf objects. We can inspect the graph’s internal ndf and edf at any time using the get_node_df() and get_edge_df() functions: # Show the graph&#39;s internal node data frame get_node_df(graph_ndf_edf) id type label 1 A one 2 A two 3 B three # Show the graph&#39;s internal edge data frame get_edge_df(graph_ndf_edf) id from to rel 1 1 2 X 2 1 3 Y Let’s view the graph using render_graph(). The output will clearly show us how the 3 nodes are connected to each other. # Show the graph using `render_graph()` render_graph(graph = graph_ndf_edf) 2.4 Adding Basic Attributes As stated previously, there is quite a bit more that you can do with node and edge data frames. Extra columns (representing attributes) filled with attribute values can be used for these two main purposes: associating data values to each node or edge providing styling attributes such as color names, node sizes, etc. We can add these extra columns/attrs when making the node or edge data frames. Here is an example where color attribute values for nodes and edges is provided along with some fillcolor values for nodes. # Create a node data frame ndf &lt;- create_node_df( n = 3, type = &quot;a&quot;, label = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;), color = c(&quot;red&quot;, &quot;blue&quot;, &quot;red&quot;), fillcolor = &quot;gray95&quot;) # Create an edge data frame edf &lt;- create_edge_df( from = c(1, 2), to = c(2, 3), color = &quot;darkgreen&quot;) # Create a graph with the ndf and edf graph_colors &lt;- create_graph( nodes_df = ndf, edges_df = edf) # Show the graph using `render_graph()` render_graph(graph = graph_colors) Note that whenever we use the default values for type or label in each add_node() call, we don’t get values for the type attribute and the label attribute is assigned the node ID value. In the ideal case, values for type and label are supplied. Something to keep in mind is that including label values that are unique or distinct across all nodes in the graph will make it possible to specify node selections and perform useful actions on specific nodes. Let’s create the graph object once more with type and label node attributes included. graph_node_type_label &lt;- create_graph() %&gt;% add_node(type = &quot;number&quot;, label = &quot;one&quot;) %&gt;% add_node(type = &quot;number&quot;, label = &quot;two&quot;) 2.5 The Internal NDF/EDF We can view the graph’s internal node data frame with the get_node_df() function so we can see that these attributes have been included alongside the graph’s nodes. get_node_df(graph_node_type_label) id type label 1 number one 2 number two Now let’s add a single, directed edge between nodes 1 and 2 using add_edge(). This edge will also be given a value for its rel attribute (to_number). After adding the edge to the graph, use the get_edges() function to show that the edge has been produced. # Add an edge between nodes `1` and `2` and # set the `rel` attribute as `to_number` graph_edge_w_ids &lt;- graph_node_type_label %&gt;% add_edge( from = 1, to = 2, rel = &quot;to_number&quot;) # Display the graph&#39;s edges (in the default # string vector format with node IDs separated # by arrows in this directed graph case) graph_edge_w_ids %&gt;% get_edges() ## [1] &quot;1-&gt;2&quot; Perhaps you don’t want to work directly with the node ID values and instead with unique node labels. This is a common practice as node ID values can be considered as less meaningful (they are not assigned by the user) but node labels and other attributes can give each node an identity and make nodes more distinguishable. In such a workflow, it’s easier to create edges based on the node label values. Supply the node labels as values for the from and to arguments and set use_labels to TRUE. To view the graph’s edges after the transformation, use get_edges() as before but, this time, use return_values = &quot;label&quot; to display the graph’s edges in terms of node label values. # Add an edge between the nodes with labels # `one` (node `1`) and `two` (node `2`) and # set the `rel` attribute as `to_number` graph_edge_w_ids &lt;- graph_node_type_label %&gt;% add_edge( from = &quot;one&quot;, to = &quot;two&quot;, rel = &quot;to_number&quot;, use_labels = TRUE) # Display the graph&#39;s edges (as a string-based # vector with pairs of node `label` values) graph_edge_w_ids %&gt;% get_edges(return_values = &quot;label&quot;) ## [1] &quot;one-&gt;two&quot; By default, the get_edges() function outputs the pairs of nodes in edges as a character vector (as above). There is also the option to return this information as a data frame (with 2 columns: from and to): # Get the graph&#39;s edges as a data frame get_edges(graph_edge_w_ids, return_type = &quot;df&quot;) from to 1 2 The addition of a node and the creation of edges can also be performed in a single add_node() step. You can use either (or both) of the optional from and to arguments in the add_node() function. Let’s make various graph objects and see how both nodes and edges can be created with a single call to add_node(). # Add initial node (ID `1`) and then # add node `2` and edge `1-&gt;2` graph_a &lt;- create_graph() %&gt;% add_node() %&gt;% add_node(from = 1) # Add initial node (ID `1`) and then # add node `2` and edge `2-&gt;1` graph_b &lt;- create_graph() %&gt;% add_node() %&gt;% add_node(to = 1) # Add 2 initial nodes (IDs `1` and # `2`) and then add node `3` and edges # `2-&gt;3` and `3-&gt;1` graph_c &lt;- create_graph() %&gt;% add_node() %&gt;% add_node() %&gt;% add_node(from = 2, to = 1) # Get all of the edges available in # each of the graphs created list(graph_a = get_edges(graph_a), graph_b = get_edges(graph_b), graph_c = get_edges(graph_c)) ## $graph_a ## [1] &quot;1-&gt;2&quot; ## ## $graph_b ## [1] &quot;2-&gt;1&quot; ## ## $graph_c ## [1] &quot;2-&gt;3&quot; &quot;3-&gt;1&quot; There are many other ways to generate a node and connect that new node to existing nodes. The from and to arguments of add_node() also accept vectors of length greater than 1. So, a new node can be connected to or from multiple nodes already in the graph. To make an example of this more succinct, we can use the node creation function add_n_nodes(). Supplying a number for the n argument creates n nodes in the graph. The add_n_nodes() function has no means to create edges like add_node() but it’s a great way to simply add a lot of nodes to the graph with one function call. Below, an example of adding one node to many nodes: # Create a graph, add 5 nodes, and then # add a node with edges to nodes `1` to `5` graph_d &lt;- create_graph() %&gt;% add_n_nodes(n = 5) %&gt;% add_node(to = 1:5) # View the graph in the RStudio Viewer render_graph(graph = graph_d) While this works and produces the result that was intended, it’s slightly inconvenient. We have to mentally keep track of which node ID values were created and use those directly in the from or to arguments to create the edges. A better way is to capture a selection of nodes and perform graph transformations with an active selection: # Create a graph, add 5 nodes, set those nodes # as a node selection, and then add a new node # with edges to all nodes in the selection graph_e &lt;- create_graph() %&gt;% add_n_nodes(n = 5) %&gt;% select_last_nodes_created() %&gt;% add_node(to = get_selection(.)) # View the graph in the RStudio Viewer render_graph(graph = graph_e) This produces the same graph as before but, this time, we didn’t have to manually supply node ID values. The select_last_nodes_created() function simply made a selection of node ID values and we retrieved those IDs using the get_selection() function. The dot (.) as the sole argument referred to the graph itself, which is needed for the graph argument to get_selection. While the graph was constructed to our specification, the nodes and the edges within that graph do not have their basic attributes filled with values. We can check this using get_node_df() and get_edges_df() and we see that values for the type, label, and rel attributes are all NA values. get_node_df(graph = graph_e) ## id type label ## 1 1 &lt;NA&gt; &lt;NA&gt; ## 2 2 &lt;NA&gt; &lt;NA&gt; ## 3 3 &lt;NA&gt; &lt;NA&gt; ## 4 4 &lt;NA&gt; &lt;NA&gt; ## 5 5 &lt;NA&gt; &lt;NA&gt; ## 6 6 &lt;NA&gt; &lt;NA&gt; get_edge_df(graph = graph_e) ## id from to rel ## 1 1 6 1 &lt;NA&gt; ## 2 2 6 2 &lt;NA&gt; ## 3 3 6 3 &lt;NA&gt; ## 4 4 6 4 &lt;NA&gt; ## 5 5 6 5 &lt;NA&gt; These values can be added later. All type and label values for nodes can be specified using set_node_attrs(). Likewise, all rel values for edges can be set with the set_edge_attrs() function. To do this unconditionally to all nodes and edges in the graph: graph_f &lt;- graph_e %&gt;% set_node_attrs( node_attr = &quot;label&quot;, values = c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;)) %&gt;% set_node_attrs( node_attr = &quot;type&quot;, value = &quot;a&quot;) %&gt;% set_edge_attrs( edge_attr = &quot;rel&quot;, values = &quot;to_number&quot;) To verify that the changes were applied, use the get_node_df() and get_edge_df() function to output the graph’s internal node and edge data frames. get_node_df(graph_f) ## id type label ## 1 1 a one ## 2 2 a two ## 3 3 a three ## 4 4 a four ## 5 5 a five ## 6 6 a six get_edge_df(graph_f) ## id from to rel ## 1 1 6 1 to_number ## 2 2 6 2 to_number ## 3 3 6 3 to_number ## 4 4 6 4 to_number ## 5 5 6 5 to_number Alternatively, we can use the get_node_attrs() and get_edge_attrs() functions to look at individual attribute values for graph nodes and edges. By supplying the graph object and the name of the attribute (e.g., type for nodes, rel for edges), we get a named vector of node or edge attribute values. # Get a vector of values for the `type` node # attribute; this returns a named vector (where # the names are the node ID values) type_node_attr_values &lt;- get_node_attrs(x = graph_f, node_attr = &quot;type&quot;) # Get a vector of values for the `rel` edge # attribute; this also returns a named vector # (where the names are the edge definitions) rel_edge_attr_values &lt;- get_edge_attrs(x = graph_f, edge_attr = &quot;rel&quot;) # Place these node and edge attribute vectors in # a list and display it list(type_node_attr_values = type_node_attr_values, rel_edge_attr_values = rel_edge_attr_values) ## $type_node_attr_values ## 1 2 3 4 5 6 ## &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; &quot;a&quot; ## ## $rel_edge_attr_values ## 6-&gt;1 6-&gt;2 6-&gt;3 6-&gt;4 6-&gt;5 ## &quot;to_number&quot; &quot;to_number&quot; &quot;to_number&quot; &quot;to_number&quot; &quot;to_number&quot; View the graph again to see that all edges are labeled with the to_number rel edge attribute. We will render the graph using output = visNetwork since that rendering method automatically includes node label and edge rel values (but not the edge type). render_graph(graph = graph_f, output = &quot;visNetwork&quot;) Go ahead, play with the graph by dragging nodes this way and that way. It’s fun! Graphs should always be this fun… "],
["attrs.html", "Chapter 3 Graph Attributes 3.1 External NDFs and EDFs 3.2 Internal NDFs and EDFs 3.3 Specific Nodes or Edges 3.4 Adding Attributes to Selections", " Chapter 3 Graph Attributes A graph can often convey more useful information when aesthetic properties are applied to its rendered form. 3.1 External NDFs and EDFs One way to add node or edge attributes, using the functions we’ve already explored, is to include these attributes and their values when generating node and edge data frames. For a node data frame, we can provide our own argument names and values when calling the create_node_df() function. In the example below, we provide values for n (the number of nodes, 4 in this case), label, and type but, in addition, we add the columns: color, shape, and data. Note that we either provide a single-length vector (i.e., a single value) or an n-length vector. Anything in between results in NA values applied to fill in the length of the data frame. The color and shape node attributes are instantly recognized by the Graphviz rendering engine. (Having the correct types of values are important here, more on that later.) The data column is ignored by the rendering engine, however, it is useful to have for other reasons (more on this later, as well). # Create a node data frame and display it ndf &lt;- create_node_df( n = 4, label = TRUE, type = &quot;lower&quot;, color = &quot;lightgreen&quot;, shape = c(&quot;circle&quot;, &quot;circle&quot;, &quot;rectangle&quot;, &quot;rectangle&quot;), data = c(2.5, 5.6, 7.4, 1.7)) ndf ## id type label color shape data ## 1 1 lower 1 lightgreen circle 2.5 ## 2 2 lower 2 lightgreen circle 5.6 ## 3 3 lower 3 lightgreen rectangle 7.4 ## 4 4 lower 4 lightgreen rectangle 1.7 We can include this node data frame in a new graph and then render it using the Graphviz engine (using render_graph() with no arguments except graph). Let’s have a look. # Incorporate the node data frame into a # new graph and display that graph; note that # there are styling attributes being used graph_4n &lt;- create_graph( nodes_df = ndf) render_graph(graph_4n) We can take a very similar approach to adding styling attributes and a data column to an edge data frame with the create_edge_df() function. Here, let’s add the penwidth (line thicknesses for edges) and the color styling attributes as well as a data attribute column. # Create an edge data frame edf &lt;- create_edge_df( from = c(1, 4, 3), to = c(2, 1, 1), rel = &quot;related_to&quot;, penwidth = c(2.5, 0.5, 1.0), color = c(&quot;pink&quot;, &quot;red&quot;, &quot;lightblue&quot;), data = c(1.1, 5.2, 3.4)) edf ## id from to rel penwidth color data ## 1 1 1 2 related_to 2.5 pink 1.1 ## 2 2 4 1 related_to 0.5 red 5.2 ## 3 3 3 1 related_to 1.0 lightblue 3.4 Now that we have the edge data frame (edf), let’s add that to the graph with the add_edge_df() function. Then, render the graph to see the styled nodes and edges. # Add the edge data frame to the graph # object, then, render the graph graph_4n_3e &lt;- graph_4n %&gt;% add_edge_df( edge_df = edf) render_graph(graph_4n_3e) 3.2 Internal NDFs and EDFs We can use the data fields for both the nodes and the edges to create styling attributes. Doing this generally requires scaling of the values (if they are numerical data, and they are in this case) and generating a new column in the internal ndf or edf that’s named for the styling attribute. Thankfully, we have some useful functions to help with this: rescale_node_attrs() and rescale_edge_attrs(). Let’s look at an example of how this works for scaling up the sizes of the node shape: # Create the `width` node attribute column # by scaling the values in the `data` column # to between 0.5 and 1.5 units graph_scaled_nodes &lt;- graph_4n_3e %&gt;% rescale_node_attrs( node_attr_from = &quot;data&quot;, to_lower_bound = 0.5, to_upper_bound = 1.5, node_attr_to = &quot;width&quot;) # Display the graph with the new styling # attribute applied render_graph(graph_scaled_nodes) This looks pretty good and, conceptually, it isn’t too difficult to reason about generating new columns with specific attribute names based on data in existing columns. Notice that the circular nodes were scaled up or down evenly whereas the rectangular one was only scaled horizontally (and this makes sense, we made a width attribute/column). If we wanted scaling both in width and in height, we also need a height column with the same scaled values. There is a set of functions to make this process easier: copy_node_attrs() and copy_edge_attrs(). It simply copies values from one attribute to a new attribute. # Copy the `width` attribute values to # a new `height` attribute; because we # want square rectangles graph_square_rects &lt;- graph_scaled_nodes %&gt;% copy_node_attrs( node_attr_from = &quot;width&quot;, node_attr_to = &quot;height&quot;) # Display the graph and observe squares render_graph(graph_square_rects) Let’s move onto some modifications of the edges. We have already applied some color values manually when constructing the edge data frame before its incorporation into the graph. Let’s use the data values available in the internal edge data frame to create scaled colors. We’ll essentially replace the color attribute values already present and scale between the grey85 and grey25 colors with the rescale_edge_attrs() function. # Create the `color` edge attribute column # by scaling the values in the `data` column # to between the `grey85` to `grey25` colors graph_grey_edges &lt;- graph_square_rects %&gt;% rescale_edge_attrs( edge_attr_from = &quot;data&quot;, to_lower_bound = &quot;grey85&quot;, to_upper_bound = &quot;grey25&quot;, edge_attr_to = &quot;color&quot;) # Display the graph with newly grayed edges render_graph(graph = graph_grey_edges) 3.3 Specific Nodes or Edges We can set node or edge attribute values for all nodes or edges in a graph, or, for specific nodes or edges in a graph. These additions can be done with the set_node_attrs() and set_edge_attrs() functions. Let’s create a random graph with 10 nodes and 15 edges and color some nodes and edges. # Create a random graph and set the # `fillcolor` as `lightgreen` for all # nodes in the graph, and, set `color` # as `blue` for all graph edges graph_1 &lt;- create_random_graph( n = 10, m = 15, directed = TRUE, set_seed = 23) %&gt;% set_node_attrs( node_attr = &quot;fillcolor&quot;, values = &quot;lightgreen&quot;) %&gt;% set_edge_attrs( edge_attr = &quot;color&quot;, values = &quot;blue&quot;) # Display the blue and green graph render_graph(graph = graph_1) We can be more selective with the node and edge coloring (or with any other attributes or data we would like to apply). # Set attribute `fillcolor` as `orange` # for nodes `1` and `3` in the graph; # for edges, set `color` to `red` for # all those edges leading to nodes # `7` and `10` graph_2 &lt;- graph_1 %&gt;% set_node_attrs( node_attr = &quot;fillcolor&quot;, values = &quot;orange&quot;, nodes = c(1, 3)) %&gt;% set_edge_attrs( edge_attr = &quot;color&quot;, values = &quot;red&quot;, to = c(7, 10)) # Display that multicolored graph render_graph(graph = graph_2) Finally, individual edges can be targeted if supplying vectors for both the from and to arguments. # Set attribute `color = &quot;black&quot;` for edges # `7`-&gt;`9` and `1`-&gt;`6` using the edge # data frame graph_3 &lt;- graph_2 %&gt;% set_edge_attrs( edge_attr = &quot;color&quot;, values = &quot;black&quot;, from = c(7, 1), to = c(9, 6)) # Display the graph render_graph(graph = graph_3) 3.4 Adding Attributes to Selections There is a large number of functions that store either a selection of nodes or edges within the graph object. Such functions begin with select_... and trav_.... Complementing this class of functions are functions that take a graph with an active selection and perform some transformation based on the selection of nodes or edges. These functions are identifiable by ending with ...ws (with selection). We’ll devote two entire chapters on the select...() and trav...() functions but, for now, we’ll provide simple use cases with select_nodes() and select_edges(). So, if we can make a selection of nodes or edges (but not both at the same time), how do we style these groups? We can do it with the set_node_attrs_ws() and set_edge_attrs_ws() functions. In this example, let’s make a simple graph, select 2 of the 4 nodes using select_nodes() and specifying nodes = c(1, 2), add fillcolor attribute values of lightgreen for those nodes with set_node_attrs_ws(), and then clear the selection with clear_selection() (it clears any selection of nodes or edges). # Create a simple graph, select nodes # `1` and `2`, color them light green; # clear the selection graph_4 &lt;- create_graph() %&gt;% add_path(4) %&gt;% select_nodes( nodes = c(1, 2)) %&gt;% set_node_attrs_ws( node_attr = &quot;fillcolor&quot;, value = &quot;lightgreen&quot;) %&gt;% clear_selection() # As a further aside on functions, we # can equivalently use the function # `select_nodes_by_id()` in the place # of `select_nodes()` in this instance # and achieve the same result; let&#39;s # now render the graph render_graph(graph = graph_4) We can follow a similar sequence for modifying edge attributes for some edges with select_edges() and set_edge_attrs_ws(). Note that we also use clear_selection() as before to clear the active selection which is, in this case, a selection of edges. # Take `graph_4`, select edges # `1-&gt;2` and `2-&gt;3`, color those red # and then clear the selection graph_5 &lt;- graph_4 %&gt;% select_edges( from = c(1, 2), to = c(2, 3)) %&gt;% set_edge_attrs_ws( edge_attr = &quot;color&quot;, value = &quot;red&quot;) %&gt;% clear_selection() render_graph(graph = graph_5) There are a few more select_...() functions that are useful and they allow you to make selections based on properties of nodes or edges in a graph. For nodes, these include: select_nodes_by_degree(): supply some information on degree (number of connections to/from/total for a node) to an expressions argument and a selection of nodes satisfying the expressions will be made select_nodes_in_neighborhood(): create a selection of nodes based on a walk distance from a specified node (supplying a single node ID for node) select_last_nodes_created(): if you just created a large amount of nodes, you can select them straight away with this function and then apply some transformation with a ..._ws() function like set_node_attrs_ws() The select_nodes() function also has some advanced functionality that can be accessed by supplying filtering statements to its conditions argument. Moreover, the select_edges() function also has selective filtering capabilities. More details are available on this in a later chapter, but for now it is good to know that this is possible. In addition, edges can be selected with: select_edges_by_edge_id(): given some edge ID values, select those exact edges select_edges_by_node_id(): given some node ID values, select all edges associated (i.e., linked to or from) those nodes select_last_edges_created(): analogous to the select_last_nodes_created() function; useful for applying attribute values to just-created edges These functions are best illustrated with a few examples. First, let’s make a random graph (26 nodes and 52 edges) and select nodes with a total degree (number of edges inbound + number of edges outbound) greater than or equal to 6. The graph will be generated by the create_random_graph() function, the selection will be performed by the select_nodes_by_degree() function (using expressions = &quot;deg &gt;= 6&quot; to express our filtering of nodes by total degree), and the coloring of the selected nodes will be accomplished using the set_node_attrs_ws() function. We’ll also do another interesting thing: color all nodes not satisfying our stated condition. This last modification will be done by inverting the node selection with invert_selection() and then using set_node_attrs_ws() again, this time on the complementary node selection. # Create a random graph and label # nodes by letters of the alphabet graph_26n_52e &lt;- create_random_graph( n = 26, m = 52, directed = TRUE, set_seed = 23) %&gt;% set_node_attrs( node_attr = &quot;label&quot;, values = LETTERS) %&gt;% set_node_attrs( node_attr = &quot;type&quot;, values = &quot;letter&quot;) # Select nodes that have a (total) # degree &gt;= 6, color these nodes # `purple` and the rest `lightgreen` graph_26n_52e &lt;- graph_26n_52e %&gt;% select_nodes_by_degree( expressions = &quot;deg &gt;= 6&quot;) %&gt;% set_node_attrs_ws( node_attr = &quot;fillcolor&quot;, value = &quot;purple&quot;) %&gt;% invert_selection() %&gt;% set_node_attrs_ws( node_attr = &quot;fillcolor&quot;, value = &quot;lightgreen&quot;) %&gt;% clear_selection() # Render the graph render_graph(graph = graph_26n_52e) Interesting! And we’re starting to visualize something of a useful insight, nodes that have greater connectedness than other nodes (distinguished by level of total degree) stand out by a visual aesthetic. This methodology is not limited to the visual either. We could, for instance, provide information on the nodes that have fulfilled the node degree requirements for reporting purposes. One can always retrieve the selection of nodes with the get_selection() function: hi_deg_nodes &lt;- graph_26n_52e %&gt;% select_nodes_by_degree( expressions = &quot;deg &gt;= 6&quot;) %&gt;% get_selection() # Report the node IDs that have # exceptionally high degree values paste( &quot;Nodes&quot;, paste(hi_deg_nodes, collapse = &quot;, &quot;), &quot;all have high degree.&quot;) ## [1] &quot;Nodes 4, 5, 8, 14, 17, 20 all have high degree.&quot; Getting a targeted list of node IDs is a great start, however, node ID values aren’t usually very meaningful to the end user. Usually, we ascribe labels to nodes to represent entities we’d like to model in the graph. Examples include (unique) user names, gene identifers, project names, etc. So, let’s get the values associated with the label and values node attributes in the selection. One strategy for doing this is involves the following sequence of functions: select_nodes_by_degree() (as before), create_subgraph_ws() to make a graph subset based on the selection of nodes, get_node_df() to return a data frame containing the graph’s nodes and all attributes (the internal node data frame), and, finally, dplyr’s select() function to select only those data frame columns we want to keep (label and value). # Load in the dplyr package library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union # Get a data frame of node `label` # and associated data values for # nodes with total degree &gt;= 6 hi_deg_node_data &lt;- graph_26n_52e %&gt;% select_nodes_by_degree( expressions = &quot;deg &gt;= 6&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() %&gt;% dplyr::select(label, value) # Display the final data frame hi_deg_node_data ## label value ## 1 D 7.5 ## 2 E 8.5 ## 3 H 10.0 ## 4 N 3.5 ## 5 Q 5.5 ## 6 T 6.5 This is more like it! But imagine that these label values could convey more meaning in a selected domain, like city names, species names, user names, or other names for things. "],
["selections.html", "Chapter 4 Selections 4.1 Setup for this Chapter 4.2 The Selection Functions 4.3 Creating a Node Selection 4.4 Creating an Edge Selection", " Chapter 4 Selections Occasionally, you’ll want to operate on a select group of nodes or edges. Some functions affect a single node or edge while others (or, sometimes, the same functions) operate on all nodes or edges in a graph. Selections allow you to target specified nodes or edges and then apply specialized functions to operate on just those selected entities. Most of the selection functions support rudimentary set operations across several calls of the selection functions (i.e., for the union, intersection, or difference between selected sets of nodes or edges). 4.1 Setup for this Chapter Ensure that the latest development build of DiagrammeR is installed. If the devtools package is not available in your R library, install it and then use the install_github() function to get the latest DiagrammeR build. install.packages(&quot;devtools&quot;) devtools::install_github(&quot;rich-iannone/DiagrammeR&quot;) library(DiagrammeR) For this chapter, the graph property_graph has been created and it’s a simple property graph of 4 nodes and 6 edges. Numerical values are assigned to the nodes as the value attribute and to the edges as the weight attribute. Nodes have unique label values, and, type group labels are available for nodes (as A and B) and rel values are set for the edges (as X, Y, and Z). This schematic provides a visual representation of the graph as well as the attributes and data associated with each node and edge. This graph adheres to the concept of a property graph in that: all nodes have an assigned, non-NA type value all edges have an assigned, non-NA rel value the graph is a directed graph We can always verify whether a graph satisfies these conditions with the is_property_graph() function, which either returns a TRUE or FALSE logical result. is_property_graph(property_graph) ## [1] TRUE Great! We’ll use this graph in most of the chapter examples to demonstrate how selections work. Working with a property graph in such examples is especially useful for showing how more complicated selections can be accomplished (i.e., using set operations and/or conditional statements). 4.2 The Selection Functions The following table provides a summary of all the available select_...() functions available in DiagrammeR. Function Description select_nodes() Select nodes graph using filtering conditions. select_nodes_by_id() Select nodes by their ID values. select_last_nodes_created() Select the last group of nodes created in the graph. select_nodes_by_degree() Select nodes on the basis of node degree. select_nodes_in_neighbourhood() Select nodes based on a walk distance from a specified node. select_edges() Select nodes graph using filtering conditions. select_edges_by_edge_id() Select edges by their ID values. select_edges_by_node_id() Select edges associated with specified node ID values. select_last_edges_created() Select the last group of edges created in the graph. When any selection is performed using a select_...() function, the selection is stored in the graph object. We can always use get_selection() to verify this: # Select nodes `1` and `4` of # `property_graph` and then return # the node IDs for the selection property_graph %&gt;% select_nodes(nodes = c(1, 4)) %&gt;% get_selection() ## [1] 1 4 And indeed the selection we get back is the selection we asked for, nodes 1 and 4. We can similarly get a selection of edge ID values and return a vector of edge IDs with get_selection(): # Select edges `1` and `4` of # `property_graph` and then return # the node IDs for the selection property_graph %&gt;% select_edges_by_edge_id(edges = c(1, 4)) %&gt;% get_selection() ## [1] 1 4 4.3 Creating a Node Selection Let’s begin our in-depth look at how to select graph nodes using the select_nodes() function. Selecting nodes in a graph with select_nodes() can be done in multiple ways: providing only a set of node ID values by providing one or more filtering statements to conditions doing both of the above, where each set of values/statements work toward filtering the nodes that will comprise the node selection The first example using select_nodes() will pertain to the first case, where you know which node ID values should make up the node selection. To show the node selection with all associated metadata as a node data frame, we’ll use 2 functions after the selection: create_subgraph_ws() (creates a subgraph, or subset, with only the selected nodes), and, get_node_df() (returns a node data frame for all nodes in the graph, now limited by the nodes in the selection). # From `property_graph`, select nodes # `1` and `3`; show the ndf based on # the node selection property_graph %&gt;% select_nodes(nodes = c(1, 3)) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6.0 3 B i0p 3.5 The select_nodes_by_id() function serves as a plug-in replacement for select_nodes() when used exactly in this way. Its nodes argument simply takes a vector of node ID values. Passing in the same node ID values will result in the same node data frame as in the previous example. # Select nodes `1` and `3` using the # `select_nodes_by_id()` function property_graph %&gt;% select_nodes_by_id(nodes = c(1, 3)) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6.0 3 B i0p 3.5 If you don’t know the node ID values that should be part of a selection - and this is often the case in practice - you can use a vector of filtering statements as conditions. Some of these can be conditions = &quot;type == 'z'&quot; (selecting nodes where the type value is z), or conditions = &quot;value &gt; 3.0&quot; (node selection where the value attribute is greater than 3.0), or, conditions = c(&quot;value &lt; 2.0&quot;, &quot;type %in% c('a', 'b', 'd')&quot;) (all nodes with value less than 2.0 and having a type value of a, b, or d). Here’s an example using an == operator to get all nodes of type A: # From our `property_graph`, select all # nodes of type `A` property_graph %&gt;% select_nodes( conditions = &quot;type == &#39;A&#39;&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6.0 2 A qhd 2.5 Need more than one type? Use the familiar %in% operator to get nodes with a type of A or B. # From our `property_graph`, select all # nodes of type `A` property_graph %&gt;% select_nodes( conditions = &quot;type %in% c(&#39;A&#39;, &#39;B&#39;)&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6.0 2 A qhd 2.5 3 B i0p 3.5 4 B 235 7.5 Regular expressions can also be used. Suppose we want nodes in this graph where the label only consists of 3 letters, and no numerals. To do this, we could use the R grepl() function with the regular expression (^[a-z]{3}$) first and then the attribute where matches are sought (in this case, label). property_graph %&gt;% select_nodes(conditions = &quot;grepl(&#39;^[a-z]{3}$&#39;, label)&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6.0 2 A qhd 2.5 Comparison operators such as &gt;, &gt;=, ==, &lt;=, &lt;, != could be used with numerical attributes to filter nodes. Here, we make a selection of nodes where any value is greater than 4.0. # Now, get all nodes with a `value` # greater than 4.0 property_graph %&gt;% select_nodes( conditions = &quot;value &gt; 4.0&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6.0 4 B 235 7.5 We can extend any conditions string to contain multiple filtering steps, linked by &amp; (AND) or | (OR) operators. To select nodes that have a value less than 3.0 or a value greater than 7.0, the following will work: property_graph %&gt;% select_nodes( conditions = &quot;value &lt; 3.0 | value &gt; 7.0&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 2 A qhd 2.5 4 B 235 7.5 To get a selection of nodes that must satisfy all conditions, link expressions with &amp;. The following example will filter nodes with a value greater than 4.0, and, with a type of A: property_graph %&gt;% select_nodes( conditions = &quot;value &gt; 4.0 &amp; type == &#39;A&#39;&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6 A vector of condition statements creates a set of AND conditions, where all conditions need to be fulfilled. The above example could be reworked using a vector of conditions statements: property_graph %&gt;% select_nodes( conditions = c(&quot;value &gt; 4.0&quot;, &quot;type == &#39;A&#39;&quot;)) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6 This retrieves the same selection and is useful for ANDing a sequence of filter statements. The situation may arise when an even more specialized selection of nodes needs to be made. Or, you’d like to make a selection, do something with it, then modify the selection (and then do yet another thing). This is where the set_op argument (short for set operation) becomes useful. Essentially the first selection will disregard set_op–it’s just making an initial selection–but the next selection will modify the previous one and how it does so depends on what’s given for set_op. These set operations are: union — creates a union of selected nodes in consecutive operations that create a selection of nodes (this is the default option) intersect — modifies the list of selected nodes such that only those nodes common to both consecutive node selection operations will retained difference — modifies the list of selected nodes such that the only nodes retained are those that are different in the second node selection operation compared to the first This schematic describes what’s happening in 2 consecutive select_...() function calls for each of the aforementioned set operations. These set operations behave in exactly the same way as the base R functions union(), intersect(), and setdiff(). Furthermore, most of the select_...() functions contain the set_op argument, so, they behave the same way with regard to modifying the node or edge selection in a series of consecutive selection operations. For our small property graph with 4 nodes (with IDs 1 through 4), creating an initial selection of nodes with select_nodes() will result in the selection of all 4 nodes in the graph. A subsequent call of select_nodes_by_id() specifying nodes = c(1, 3) and set_op = &quot;difference&quot; will result in a selection of nodes 2 and 4 (the difference of removing 1 and 3 from the complete set). Let’s verify the final selection by finishing with get_selection() this time, which outputs node ID values for the selected nodes. property_graph %&gt;% select_nodes() %&gt;% select_nodes_by_id( nodes = c(1, 3), set_op = &quot;difference&quot;) %&gt;% get_selection() ## [1] 2 4 For a somewhat more realistic application, where the node IDs are not known, imagine a situation where you would want to select nodes of a certain degree but only those having a certain value range. Here, we do something to that effect, where we want to select nodes with an outdegree (number of outward edges from a given node) greater than 1 with the added condition of having a value greater than 4.0. In this case, we want the intersection of these selections. property_graph %&gt;% select_nodes_by_degree( expressions = &quot;outdeg &gt; 1&quot;) %&gt;% select_nodes( conditions = &quot;value &gt; 4.0&quot;, set_op = &quot;intersect&quot;) %&gt;% create_subgraph_ws() %&gt;% get_node_df() id type label value 1 A sjd 6 This returns a single value. Just so you know, using set_op == &quot;union&quot; would result in 3 nodes in the selection (1, 2, and 4), and, using set_op == &quot;difference&quot; would yield a selection with the node 2. Most often, selections will be performed without knowing the node ID values for the nodes to be selected but, instead, some attributes of the nodes to be selected and perhaps the nodes to exclude from that selection. And this sort of makes sense when you have thousands, hundreds of thousands, and maybe millions of nodes: you’re not often going to visualize the entire graph at this point (much like you wouldn’t usually display a table of even hundreds of rows). 4.4 Creating an Edge Selection We’ll run through selections of edges in perhaps an abbreviated fashion since many of the concepts that apply to node selections also apply to edge selections. First off, recall that edges have ID values! This is great because edges can also be defined by their attachments to nodes. So an edge defined as 1-&gt;2 in a directed graph (where 1 and 2 are node ID values) can also be defined as an edge with ID 1 (in this hypothetical case). Let’s have a look at the internal edge data frame within property_graph to remind ourselves of the edge ID values available in this graph: property_graph %&gt;% get_edge_df() id from to rel weight 1 2 4 X 3.7 2 1 4 X 8.3 3 2 3 Y 12.5 4 3 4 Y 1.3 5 1 3 Z 2.9 6 1 2 Z 2.4 The first column in the edge data frame is the id attribute. The next two are from and to, and rel is always the 4th attribute column. We can select edges using IDs (of both the edge and node varieties) with three different functions: select_edges() select_edges_by_edge_id() select_edges_by_node_id() "],
["fcns-creation.html", "Chapter 5 Functions: Creation, I/O 5.1 create_node_df() 5.2 create_edge_df() 5.3 combine_ndfs() 5.4 combine_edfs() 5.5 create_graph() 5.6 create_random_graph() 5.7 combine_graphs() 5.8 import_graph() 5.9 from_adj_matrix() 5.10 from_igraph() 5.11 to_igraph() 5.12 render_graph() 5.13 export_graph() 5.14 export_csv() 5.15 save_graph() 5.16 open_graph() 5.17 Graph Metadata 5.18 Graph Series", " Chapter 5 Functions: Creation, I/O 5.1 create_node_df() 5.2 create_edge_df() 5.3 combine_ndfs() 5.4 combine_edfs() 5.5 create_graph() 5.6 create_random_graph() 5.7 combine_graphs() 5.8 import_graph() 5.9 from_adj_matrix() 5.10 from_igraph() 5.11 to_igraph() 5.12 render_graph() 5.13 export_graph() 5.14 export_csv() 5.15 save_graph() 5.16 open_graph() 5.17 Graph Metadata 5.18 Graph Series "],
["fcns-selection.html", "Chapter 6 Functions: Selection 6.1 select_nodes() 6.2 select_edges() 6.3 select_last_nodes_created() 6.4 select_last_edges_created() 6.5 select_nodes_by_id() 6.6 select_nodes_in_neighborhood() 6.7 select_nodes_by_degree() 6.8 select_edges_by_edge_id() 6.9 select_edges_by_node_id() 6.10 invert_selection() 6.11 clear_selection() 6.12 get_selection()", " Chapter 6 Functions: Selection 6.1 select_nodes() 6.2 select_edges() 6.3 select_last_nodes_created() 6.4 select_last_edges_created() 6.5 select_nodes_by_id() 6.6 select_nodes_in_neighborhood() 6.7 select_nodes_by_degree() 6.8 select_edges_by_edge_id() 6.9 select_edges_by_node_id() 6.10 invert_selection() 6.11 clear_selection() 6.12 get_selection() "],
["fcns-traversals.html", "Chapter 7 Functions: Traversals 7.1 trav_out() 7.2 trav_in() 7.3 trav_both() 7.4 trav_out_edge() 7.5 trav_in_edge() 7.6 trav_both_edge() 7.7 trav_out_node() 7.8 trav_in_node() 7.9 trav_reverse_edge()", " Chapter 7 Functions: Traversals 7.1 trav_out() 7.2 trav_in() 7.3 trav_both() 7.4 trav_out_edge() 7.5 trav_in_edge() 7.6 trav_both_edge() 7.7 trav_out_node() 7.8 trav_in_node() 7.9 trav_reverse_edge() "],
["fcns-inspection.html", "Chapter 8 Functions: Inspection 8.1 node_info() 8.2 edge_info() 8.3 graph_info() 8.4 get_nodes() 8.5 get_edges() 8.6 get_predecessors() 8.7 get_successors() 8.8 get_node_df() 8.9 get_edge_df() 8.10 node_count() 8.11 edge_count() 8.12 node_present() 8.13 edge_present() 8.14 is_graph_empty() 8.15 is_graph_directed() 8.16 is_graph_connected() 8.17 is_property_graph() 8.18 get_degree_in() 8.19 get_degree_out() 8.20 get_degree_total() 8.21 get_degree_histogram() 8.22 get_degree_distribution() 8.23 get_graph_diameter() 8.24 get_constraint() 8.25 get_betweenness() 8.26 get_closeness() 8.27 get_bridging() 8.28 get_eccentricity() 8.29 get_jaccard_similarity() 8.30 get_dice_similarity() 8.31 get_periphery() 8.32 get_cmty_walktrap() 8.33 get_cmty_louvain() 8.34 get_cmty_l_eigenvector() 8.35 get_cmty_fast_greedy() 8.36 get_cmty_edge_btwns() 8.37 get_nbrs() 8.38 get_non_nbrs() 8.39 get_common_neighbors() 8.40 get_similar_nbrs() 8.41 get_paths() 8.42 get_w_connected_cmpts() 8.43 get_s_connected_cmpts() 8.44 get_articulation_points()", " Chapter 8 Functions: Inspection 8.1 node_info() 8.2 edge_info() 8.3 graph_info() 8.4 get_nodes() 8.5 get_edges() 8.6 get_predecessors() 8.7 get_successors() 8.8 get_node_df() 8.9 get_edge_df() 8.10 node_count() 8.11 edge_count() 8.12 node_present() 8.13 edge_present() 8.14 is_graph_empty() 8.15 is_graph_directed() 8.16 is_graph_connected() 8.17 is_property_graph() 8.18 get_degree_in() 8.19 get_degree_out() 8.20 get_degree_total() 8.21 get_degree_histogram() 8.22 get_degree_distribution() 8.23 get_graph_diameter() 8.24 get_constraint() 8.25 get_betweenness() 8.26 get_closeness() 8.27 get_bridging() 8.28 get_eccentricity() 8.29 get_jaccard_similarity() 8.30 get_dice_similarity() 8.31 get_periphery() 8.32 get_cmty_walktrap() 8.33 get_cmty_louvain() 8.34 get_cmty_l_eigenvector() 8.35 get_cmty_fast_greedy() 8.36 get_cmty_edge_btwns() 8.37 get_nbrs() 8.38 get_non_nbrs() 8.39 get_common_neighbors() 8.40 get_similar_nbrs() 8.41 get_paths() 8.42 get_w_connected_cmpts() 8.43 get_s_connected_cmpts() 8.44 get_articulation_points() "],
["fcns-modification.html", "Chapter 9 Functions: Modification 9.1 add_node() 9.2 add_edge() 9.3 add_node_df() 9.4 add_edge_df() 9.5 add_n_nodes() 9.6 add_n_nodes_ws() 9.7 add_edges_w_string() 9.8 rev_edge_dir() 9.9 rev_edge_dir_ws() 9.10 add_nodes_from_table() 9.11 add_edges_from_table() 9.12 add_nodes_from_df_cols() 9.13 add_path() 9.14 add_cycle() 9.15 add_star() 9.16 add_prism() 9.17 add_balanced_tree() 9.18 add_full_graph() 9.19 join_node_attrs() 9.20 join_edge_attrs() 9.21 set_graph_undirected() 9.22 delete_node() 9.23 delete_edge() 9.24 delete_nodes_ws() 9.25 delete_edges_ws() 9.26 node_type() 9.27 edge_rel() 9.28 create_subgraph_ws() 9.29 get_min_spanning_tree() 9.30 set_df_as_node_attr() 9.31 set_df_as_edge_attr() 9.32 set_node_attrs() 9.33 set_edge_attrs() 9.34 set_node_attrs_ws() 9.35 set_edge_attrs_ws() 9.36 copy_node_attrs() 9.37 copy_edge_attrs() 9.38 drop_node_attrs() 9.39 drop_edge_attrs() 9.40 rename_node_attrs() 9.41 rename_edge_attrs() 9.42 rescale_node_attrs() 9.43 rescale_edge_attrs() 9.44 mutate_node_attrs() 9.45 mutate_edge_attrs() 9.46 recode_node_attrs() 9.47 recode_edge_attrs() 9.48 colorize_node_attrs() 9.49 colorize_edge_attrs()", " Chapter 9 Functions: Modification 9.1 add_node() 9.2 add_edge() 9.3 add_node_df() 9.4 add_edge_df() 9.5 add_n_nodes() 9.6 add_n_nodes_ws() 9.7 add_edges_w_string() 9.8 rev_edge_dir() 9.9 rev_edge_dir_ws() 9.10 add_nodes_from_table() 9.11 add_edges_from_table() 9.12 add_nodes_from_df_cols() 9.13 add_path() 9.14 add_cycle() 9.15 add_star() 9.16 add_prism() 9.17 add_balanced_tree() 9.18 add_full_graph() 9.19 join_node_attrs() 9.20 join_edge_attrs() 9.21 set_graph_undirected() 9.22 delete_node() 9.23 delete_edge() 9.24 delete_nodes_ws() 9.25 delete_edges_ws() 9.26 node_type() 9.27 edge_rel() 9.28 create_subgraph_ws() 9.29 get_min_spanning_tree() 9.30 set_df_as_node_attr() 9.31 set_df_as_edge_attr() 9.32 set_node_attrs() 9.33 set_edge_attrs() 9.34 set_node_attrs_ws() 9.35 set_edge_attrs_ws() 9.36 copy_node_attrs() 9.37 copy_edge_attrs() 9.38 drop_node_attrs() 9.39 drop_edge_attrs() 9.40 rename_node_attrs() 9.41 rename_edge_attrs() 9.42 rescale_node_attrs() 9.43 rescale_edge_attrs() 9.44 mutate_node_attrs() 9.45 mutate_edge_attrs() 9.46 recode_node_attrs() 9.47 recode_edge_attrs() 9.48 colorize_node_attrs() 9.49 colorize_edge_attrs() "],
["fcns-caching.html", "Chapter 10 Functions: Caching Data 10.1 set_cache() 10.2 get_cache() 10.3 cache_node_attrs() 10.4 cache_edge_attrs() 10.5 cache_node_attrs_ws() 10.6 cache_edge_attrs_ws() 10.7 cache_node_count_ws() 10.8 cache_edge_count_ws()", " Chapter 10 Functions: Caching Data 10.1 set_cache() 10.2 get_cache() 10.3 cache_node_attrs() 10.4 cache_edge_attrs() 10.5 cache_node_attrs_ws() 10.6 cache_edge_attrs_ws() 10.7 cache_node_count_ws() 10.8 cache_edge_count_ws() "],
["fcns-g-metadata.html", "Chapter 11 Functions: Graph Metadata 11.1 set_graph_name() 11.2 set_graph_time() 11.3 set_global_graph_attrs() 11.4 add_global_graph_attrs() 11.5 get_global_graph_attrs() 11.6 delete_global_graph_attrs() 11.7 clear_global_graph_attrs()", " Chapter 11 Functions: Graph Metadata 11.1 set_graph_name() 11.2 set_graph_time() 11.3 set_global_graph_attrs() 11.4 add_global_graph_attrs() 11.5 get_global_graph_attrs() 11.6 delete_global_graph_attrs() 11.7 clear_global_graph_attrs() "],
["fcns-g-series.html", "Chapter 12 Functions: Graph Series 12.1 create_series() 12.2 add_to_series() 12.3 remove_from_series() 12.4 subset_series() 12.5 get_graph_from_series() 12.6 trigger_script() 12.7 series_info() 12.8 graph_count() 12.9 render_graph_from_series()", " Chapter 12 Functions: Graph Series 12.1 create_series() 12.2 add_to_series() 12.3 remove_from_series() 12.4 subset_series() 12.5 get_graph_from_series() 12.6 trigger_script() 12.7 series_info() 12.8 graph_count() 12.9 render_graph_from_series() "]
]
